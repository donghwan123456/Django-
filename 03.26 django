read - > 전체 게시글 조회 & 단일 게시글 조회

create로직 구현 위해서 필요한 view함수 
- new :  사용자 입력 데이터 받을 페이지 렌더링
- create : 사용자 입력한 데이터 받아 DB에 저장

HTTP request methods : 데이터/리소스에 어떤 요청/행동을 원하는지 나타내는것
        - GET /// POST
Get method :  특정 리소스 조회하는 요청
              데이터 전달할 때 URL에서 Query String 형식으로 보내짐
Post method :  특정 리소스에 변경(생성, 수정, 삭제)을 요구하는 요청
               데이터는 전달할 때 HTTP body에 담겨 보내짐

HTTP response statuse code
 : 특정 HTTP요청이 성공적으로 완료되었는지를 세자리 숫자로 표현하기로 약속한 것
403 forbidden
 : 서버에 요청이 전달은 되었지만 권한 때문에 거절되었다는 것을 의미
CSRF - cross-site-Request-Forgery
 : 사이트 간 요청 위조 - 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하여 특정 
   웹 페이지를 보안에 취약하게 하거나 수정,삭제 등의 작업을 하게 만드는 공격 방법
CSRF Token 적용
 : DTL의 csrf_token 태그를 사용해 손쉽게 사용자에게 토큰 값 부여 가능
 : 요청 시 토큰 값도 함께 서버로 전송될 수 있도록 하는 것
요청시 csrf_token을 함께 보내야 하는 이유
 : django 서버는 해당 요청이 db에 데이터를 하나 생성하는 요청에 대해 "django가 직접 제공한
   페이지에서 요청을 보낸 것인지"에 대한 확인 수단이 필요한 것
 : 겉모습이 똑같은 위조 사이트나 정상적이지 않은 요청에 대한 방어 수단
 : 기존 : 요청데이터 -> 게시글 작성
 : 변경 : 요청데이터 + 인증토큰 -> 게시글 작성
Post일 때만 Token 확인하는 이유
 : Post는 단순 조회 위한 get과는 다릴 특정 리소스에 변경을 요구하는 의미와 기술적 부분 가짐
   DB에 조작을 가하는 요청은 인증 수단 필요
   => 데이터베이스에 대한 변경사항 만드는 요청이기에 토큰 사용해 최소한의 신원 확인
게시글 작성 결과
 : 게시글 생성 후 개발자 도구 사용해 Form Data가 전송되는 것 확인
   더 이상 URL에 Query String 형태로 보낸 데이터가 표기되지 않음

게시글 작성 후 완료 알리는 페이지 응답하는 것
:게시글을 조회해달라는 요청이 아닌 작성해달라는 요청이기 때문에 
 게시글 저장 후 페이지 응답하는 것은 post에 대한 적절한 응답 아님
 => 데이터 저장 후 페이지 주는 것이 아닌 다른 페이지로 사용자를 보내야 한다
                                                       >> 사용자를 보낸다 = 사용자가 get요청을 한번 더 보내도록 해야한다
redirect()
 : 클라이언트가 인자에 작성된 주소로 다시 요청을 보내도록 하는 함수
 - 해당 redirect에서 클라이언트는 detail url로 요청 다시 보내게 됨
 - detail view 함수가 호출되어 이의 반환결과인 detail 페이지를 응답 받음
 - 사용자는 게시글 작성 후 작성된 게시글의 detail페이지로 이동하는 것으로 느낌
 - 게시글 작성 후 생성 된 게시글의 detail페이지로 redirect 되었는지 확인하고
 - create요청 이후 detail로 다시 요청 보냈다는 것 알 수 있음

Delete

Update 로직 구현 위해 필요한 view함수
 : 사용자 입력 데이터를 받을 페이지 렌더링 : edit
 : 사용자가 입력한 데이터 받아 DB에 저장 : update

 GET과 POST비교
                                Get                   Post
데이터 전송 방식   |  url의 query string parameter   |   HTTP body
데이터 크기 제한   | 브라우저 제공 url의 최대 길이     |   제한 없음
사용 목적         |  데이터 검색 및 조회              |   데이터 제출 및 조작

GET요청이 필요한 경우
: 캐싱 및 성능
    - get요청은 캐시(cache)될 수 있고 이전에 요청한 정보 새로 요청하지 않고 사용할 수 있음
    - 동일 검색 결과 여러번 요청하는 경우 get요청은 캐시를 활용해 더 빠르게 응답 가능

: 가시성 및 공유
    - get요청은 url에 데이터가 노출되어 있기 때문에 사용자가 해당 url 북마크하거나 다른사람과 공유하기 용이
: RESTful API 설계
    - HTTP 메서드의 의미에 따라 동작하게 디자인 된 API 일관성 유지 가능

캐시(cache)
 : 데이터나 정보를 임시로 저장해두는 메모리나 디스크 공간
 : 이전에 접근한 데이터 빠르게 검색하고 접근할 수 있도록 함

ORM
호환되지 않는 유형의 시스템 간에 데이터 변환하는 기술
django와 database 언어 달라서 중간에 내장된 orm이 이를 해석

query
데이터 베이스에 특정 데이터를 보여달라는 요청
파이썬으로 작성한 코드가 orm에 의해 sql로 변환되어 데이터베이스에 전달되며
데이터 베이스의 응답 데이터를 qrm이 queryset이라는 자료형태로 변환해 전달

qeury stat
: 데이터 베이스에게서 전달받은 객체 목록
: django orm을 통해 만들어진 자료형
: 데이터베이스가 단일 객체 반환 할 때는 queryset이 아닌 class의 인스턴스로 반환


qeuryset API - db에 데이터 저장,조회,수정,삭제하는 것

 - create : 
 - pip freeze > requirements.txt :txt파일에 반영 
 ....

데이터 객체 생성 3가지 방법
: create() 메서드 활용
: 특정 테이블에 새로운 행 추가하여 데이터 추가, 인스턴스 변수에 값 할당+save
: 

save() - 객체를 데이터베이스에 저장하는 메서드

조회메서드
: all() 전체 데이터 조회
: filter() 특정 조건 데이터 조회 
: get() 단일 데이터 조회
     -> 특징 : - 객체 찾을 수 없으면 Doesnotexist예외 발생
               둘 이상 객체 찾으면 multipleobjectsreturned예외 발생
               - 이런 특징때무네 primary key와 같이 고유성을 보장하는 조회에서 사용해야함

update// save// delete
